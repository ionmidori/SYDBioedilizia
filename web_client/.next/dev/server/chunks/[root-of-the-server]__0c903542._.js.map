{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User01/.gemini/antigravity/scratch/renovation-next/web_client/lib/firebase-admin.ts"],"sourcesContent":["import { initializeApp, cert, getApps, App } from 'firebase-admin/app';\r\nimport { getFirestore, Firestore } from 'firebase-admin/firestore';\r\nimport { getStorage, Storage } from 'firebase-admin/storage';\r\n\r\n/**\r\n * Firebase Admin SDK initialization for server-side operations\r\n * Singleton pattern ensures single instance across serverless invocations\r\n * ALWAYS loads from firebase-service-account.json for reliability\r\n */\r\n\r\nlet firebaseApp: App | undefined;\r\nlet firestoreInstance: Firestore | undefined;\r\nlet storageInstance: Storage | undefined;\r\n\r\n/**\r\n * ✅ CRITICAL FIX #2: Validate Firebase credentials format\r\n * Prevents security risks from malformed credentials\r\n */\r\n/**\r\n * ✅ CRITICAL FIX #2: Sanitize and Validate Firebase Private Key\r\n * Prevents security risks from malformed credentials and ensures correct format.\r\n * Returns the sanitized private key.\r\n */\r\nfunction sanitizeAndValidatePrivateKey(privateKey: string): string {\r\n    if (!privateKey) {\r\n        throw new Error('[Firebase] Private key is missing');\r\n    }\r\n\r\n    // 1. Sanitize: Handle both escaped (\\n) and unescaped newlines\r\n    let sanitizedKey = privateKey.replace(/\\\\n/g, '\\n');\r\n\r\n    // 2. Sanitize: Remove wrapping quotes if present (common env var issue)\r\n    if (sanitizedKey.startsWith('\"') && sanitizedKey.endsWith('\"')) {\r\n        sanitizedKey = sanitizedKey.slice(1, -1);\r\n    }\r\n    if (sanitizedKey.startsWith(\"'\") && sanitizedKey.endsWith(\"'\")) {\r\n        sanitizedKey = sanitizedKey.slice(1, -1);\r\n    }\r\n\r\n    // 3. Validation: Check for standard PEM format markers\r\n    if (!sanitizedKey.includes('BEGIN PRIVATE KEY') || !sanitizedKey.includes('END PRIVATE KEY')) {\r\n        throw new Error('[Firebase] Invalid private key format - must be a valid RSA private key (PEM format)');\r\n    }\r\n\r\n    // 4. Validation: content check\r\n    const keyContent = sanitizedKey.split('BEGIN PRIVATE KEY')[1]?.split('END PRIVATE KEY')[0];\r\n    if (!keyContent || keyContent.trim().length < 100) {\r\n        throw new Error('[Firebase] Private key appears to be truncated or empty');\r\n    }\r\n\r\n    // 5. Re-verify newlines for PEM validity\r\n    if (!sanitizedKey.includes('\\n')) {\r\n        throw new Error('[Firebase] Private key invalid: missing newlines after sanitization');\r\n    }\r\n\r\n    return sanitizedKey;\r\n}\r\n\r\n/**\r\n * Validates other credential fields\r\n */\r\nfunction validateServiceAccount(clientEmail: string, projectId: string): void {\r\n    // Validate email format\r\n    if (!clientEmail || !clientEmail.includes('@') || !clientEmail.endsWith('.gserviceaccount.com')) {\r\n        throw new Error(`[Firebase] Invalid service account email: ${clientEmail} - must end with .gserviceaccount.com`);\r\n    }\r\n\r\n    // Validate project ID format\r\n    if (!projectId || projectId.length < 6 || !/^[a-z0-9-]+$/.test(projectId)) {\r\n        throw new Error(`[Firebase] Invalid project ID: ${projectId} - must contain only lowercase letters, numbers, and hyphens`);\r\n    }\r\n}\r\n\r\n/**\r\n * Initialize Firebase Admin SDK\r\n * Loads from environment variables (Vercel-compatible) or falls back to JSON file\r\n */\r\nfunction initializeFirebase(): App {\r\n    if (getApps().length === 0) {\r\n        console.log('[Firebase] Initializing Firebase Admin SDK...');\r\n\r\n        try {\r\n            // Try environment variables first (Vercel-compatible)\r\n            // Try environment variables first (Vercel-compatible)\r\n            const rawPrivateKey = process.env.FIREBASE_PRIVATE_KEY;\r\n\r\n            if (rawPrivateKey && process.env.FIREBASE_CLIENT_EMAIL && process.env.FIREBASE_PROJECT_ID) {\r\n                console.log('[Firebase] Loading credentials from environment variables');\r\n\r\n                // ✅ CRITICAL FIX #2: Sanitize & Validate\r\n                const privateKey = sanitizeAndValidatePrivateKey(rawPrivateKey);\r\n\r\n                validateServiceAccount(\r\n                    process.env.FIREBASE_CLIENT_EMAIL,\r\n                    process.env.FIREBASE_PROJECT_ID\r\n                );\r\n\r\n                firebaseApp = initializeApp({\r\n                    credential: cert({\r\n                        projectId: process.env.FIREBASE_PROJECT_ID,\r\n                        clientEmail: process.env.FIREBASE_CLIENT_EMAIL,\r\n                        privateKey: privateKey,\r\n                    }),\r\n                    storageBucket: `${process.env.FIREBASE_PROJECT_ID}.firebasestorage.app`,\r\n                });\r\n\r\n                console.log('[Firebase] ✅ Successfully initialized from environment variables');\r\n\r\n                return firebaseApp;\r\n            }\r\n\r\n            // Fallback to JSON file (local development)\r\n            const fs = require('fs');\r\n            const path = require('path');\r\n\r\n            const serviceAccountPath = path.join(process.cwd(), 'firebase-service-account.json');\r\n\r\n            console.log('[Firebase] Loading credentials from:', serviceAccountPath);\r\n\r\n            if (!fs.existsSync(serviceAccountPath)) {\r\n                throw new Error(`Firebase service account file not found at: ${serviceAccountPath}. Please ensure firebase-service-account.json exists in the project root OR set environment variables.`);\r\n            }\r\n\r\n            const serviceAccount = JSON.parse(fs.readFileSync(serviceAccountPath, 'utf8'));\r\n\r\n            // ✅ CRITICAL FIX #2: Validate JSON file credentials\r\n            const privateKey = sanitizeAndValidatePrivateKey(serviceAccount.private_key);\r\n\r\n            validateServiceAccount(\r\n                serviceAccount.client_email,\r\n                serviceAccount.project_id\r\n            );\r\n\r\n            firebaseApp = initializeApp({\r\n                credential: cert({\r\n                    ...serviceAccount,\r\n                    private_key: privateKey // Use sanitized key\r\n                }),\r\n                storageBucket: serviceAccount.project_id + '.firebasestorage.app',\r\n            });\r\n\r\n            console.log('[Firebase] ✅ Successfully initialized from JSON file');\r\n\r\n            return firebaseApp!; // Assert not null since we just initialized it\r\n        } catch (error) {\r\n            console.error('[Firebase] ❌ Initialization FAILED:', error);\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    return getApps()[0];\r\n}\r\n\r\n/**\r\n * Get Firestore instance (singleton)\r\n * CRITICAL FIX: Removed settings() call to prevent re-initialization error\r\n */\r\nexport function getFirestoreDb(): Firestore {\r\n    if (!firestoreInstance) {\r\n        const app = initializeFirebase();\r\n        firestoreInstance = getFirestore(app);\r\n        // REMOVED: settings() call - was causing \"already initialized\" error\r\n    }\r\n\r\n    return firestoreInstance;\r\n}\r\n\r\n/**\r\n * Get Firebase Storage instance (singleton)\r\n */\r\nexport function getFirebaseStorage(): Storage {\r\n    if (!storageInstance) {\r\n        const app = initializeFirebase();\r\n        storageInstance = getStorage(app);\r\n    }\r\n\r\n    return storageInstance;\r\n}\r\n\r\n// Export convenient aliases\r\nexport const db = getFirestoreDb;\r\nexport const storage = getFirebaseStorage;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 236, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User01/.gemini/antigravity/scratch/renovation-next/web_client/lib/db/schema.ts"],"sourcesContent":["import { Timestamp } from 'firebase-admin/firestore';\r\n\r\n/**\r\n * Firestore Schema Definitions\r\n * Collections: users, sessions, messages (subcollection), leads\r\n */\r\n\r\n// /users/{userId}\r\nexport interface User {\r\n    email: string;\r\n    displayName: string;\r\n    photoURL?: string;\r\n    createdAt: Timestamp;\r\n    plan: 'free' | 'pro';\r\n    metadata: {\r\n        totalSessions: number;\r\n        totalMessages: number;\r\n        totalImagesGenerated: number;\r\n    };\r\n}\r\n\r\n// /sessions/{sessionId}\r\nexport interface Session {\r\n    userId?: string;\r\n    createdAt: Timestamp;\r\n    updatedAt: Timestamp;\r\n    summary?: string; // AI-generated summary for old sessions\r\n    messageCount: number;\r\n    status: 'active' | 'archived';\r\n    lastMessagePreview?: string;\r\n}\r\n\r\n// /sessions/{sessionId}/messages/{messageId}\r\nexport interface Message {\r\n    role: 'user' | 'assistant' | 'system';\r\n    content: string;\r\n    timestamp: Timestamp;\r\n    tokens?: {\r\n        input: number;\r\n        output: number;\r\n    };\r\n    imageUrl?: string; // For generated images\r\n    toolCalls?: Array<{\r\n        name: string;\r\n        args: any;\r\n        result: any;\r\n    }>;\r\n}\r\n\r\n// /leads/{leadId}\r\nexport interface Lead {\r\n    sessionId: string;\r\n    userId?: string;\r\n    name: string;\r\n    email: string;\r\n    phone?: string;\r\n    projectDetails: string;\r\n    roomType?: string;\r\n    style?: string;\r\n    estimatedBudget?: string;\r\n    createdAt: Timestamp;\r\n    status: 'new' | 'contacted' | 'converted';\r\n}\r\n\r\n// Collection names (constants for type safety)\r\nexport const COLLECTIONS = {\r\n    USERS: 'users',\r\n    SESSIONS: 'sessions',\r\n    MESSAGES: 'messages', // subcollection under sessions\r\n    LEADS: 'leads',\r\n} as const;\r\n"],"names":[],"mappings":";;;;AAiEO,MAAM,cAAc;IACvB,OAAO;IACP,UAAU;IACV,UAAU;IACV,OAAO;AACX"}},
    {"offset": {"line": 252, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User01/.gemini/antigravity/scratch/renovation-next/web_client/lib/db/messages.ts"],"sourcesContent":["import { db } from '../firebase-admin';\r\nimport { COLLECTIONS } from './schema';\r\nimport { FieldValue } from 'firebase-admin/firestore';\r\n\r\n/**\r\n * Get conversation context (last N messages) for a session\r\n * Optimized for low latency (~30-50ms)\r\n */\r\nexport async function getConversationContext(\r\n    sessionId: string,\r\n    limit: number = 10\r\n): Promise<Array<{ role: string; content: string; toolInvocations?: any[] }>> {\r\n    try {\r\n        const firestore = db();\r\n\r\n        // Query last N messages, ordered by timestamp descending\r\n        const messagesRef = firestore\r\n            .collection(COLLECTIONS.SESSIONS)\r\n            .doc(sessionId)\r\n            .collection(COLLECTIONS.MESSAGES)\r\n            .orderBy('timestamp', 'desc')\r\n            .limit(limit);\r\n\r\n        const snapshot = await messagesRef.get();\r\n\r\n        if (snapshot.empty) {\r\n            console.log(`[getConversationContext] No messages found for session: ${sessionId}`);\r\n            return [];\r\n        }\r\n\r\n        // Convert to array and reverse (oldest first for chat context)\r\n        const messages = snapshot.docs\r\n            .map(doc => {\r\n                const data = doc.data();\r\n                return {\r\n                    role: data.role as 'user' | 'assistant' | 'system',\r\n                    content: data.content as string,\r\n                    toolInvocations: data.toolCalls?.map((tc: any) => ({\r\n                        toolCallId: crypto.randomUUID(), // Generate transient ID\r\n                        toolName: tc.name,\r\n                        args: tc.args,\r\n                        state: 'result',\r\n                        result: tc.result\r\n                    }))\r\n                };\r\n            })\r\n            .reverse(); // Reverse to get chronological order\r\n\r\n        console.log(`[getConversationContext] Loaded ${messages.length} messages for session: ${sessionId}`);\r\n        return messages;\r\n\r\n    } catch (error) {\r\n        console.error('[getConversationContext] Error loading context:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n/**\r\n * Save a message to Firestore\r\n * Non-blocking operation for performance\r\n */\r\nexport async function saveMessage(\r\n    sessionId: string,\r\n    role: 'user' | 'assistant' | 'system',\r\n    content: string,\r\n    metadata?: {\r\n        imageUrl?: string;\r\n        toolCalls?: Array<{ name: string; args: any; result: any }>;\r\n        tokens?: { input: number; output: number };\r\n    }\r\n): Promise<void> {\r\n    try {\r\n        const firestore = db();\r\n\r\n        const messageData = {\r\n            role,\r\n            content,\r\n            timestamp: FieldValue.serverTimestamp(),\r\n            ...metadata,\r\n        };\r\n\r\n        // Add message to subcollection\r\n        await firestore\r\n            .collection(COLLECTIONS.SESSIONS)\r\n            .doc(sessionId)\r\n            .collection(COLLECTIONS.MESSAGES)\r\n            .add(messageData);\r\n\r\n        // Update session metadata\r\n        await firestore\r\n            .collection(COLLECTIONS.SESSIONS)\r\n            .doc(sessionId)\r\n            .set(\r\n                {\r\n                    updatedAt: FieldValue.serverTimestamp(),\r\n                    messageCount: FieldValue.increment(1),\r\n                    lastMessagePreview: content.substring(0, 100),\r\n                },\r\n                { merge: true }\r\n            );\r\n\r\n        console.log(`[saveMessage] Saved ${role} message to session: ${sessionId}`);\r\n\r\n    } catch (error) {\r\n        console.error('[saveMessage] Error saving message:', error);\r\n        // Don't throw - message save failures shouldn't break the chat\r\n    }\r\n}\r\n\r\n/**\r\n * Create or update a session\r\n */\r\nexport async function ensureSession(sessionId: string): Promise<void> {\r\n    try {\r\n        const firestore = db();\r\n        const sessionRef = firestore.collection(COLLECTIONS.SESSIONS).doc(sessionId);\r\n\r\n        const session = await sessionRef.get();\r\n\r\n        if (!session.exists) {\r\n            await sessionRef.set({\r\n                createdAt: FieldValue.serverTimestamp(),\r\n                updatedAt: FieldValue.serverTimestamp(),\r\n                messageCount: 0,\r\n                status: 'active',\r\n            });\r\n\r\n            console.log(`[ensureSession] Created new session: ${sessionId}`);\r\n        }\r\n    } catch (error) {\r\n        console.error('[ensureSession] Error ensuring session:', error);\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;;;;;;AAMO,eAAe,uBAClB,SAAiB,EACjB,QAAgB,EAAE;IAElB,IAAI;QACA,MAAM,YAAY,IAAA,8IAAE;QAEpB,yDAAyD;QACzD,MAAM,cAAc,UACf,UAAU,CAAC,kJAAW,CAAC,QAAQ,EAC/B,GAAG,CAAC,WACJ,UAAU,CAAC,kJAAW,CAAC,QAAQ,EAC/B,OAAO,CAAC,aAAa,QACrB,KAAK,CAAC;QAEX,MAAM,WAAW,MAAM,YAAY,GAAG;QAEtC,IAAI,SAAS,KAAK,EAAE;YAChB,QAAQ,GAAG,CAAC,CAAC,wDAAwD,EAAE,WAAW;YAClF,OAAO,EAAE;QACb;QAEA,+DAA+D;QAC/D,MAAM,WAAW,SAAS,IAAI,CACzB,GAAG,CAAC,CAAA;YACD,MAAM,OAAO,IAAI,IAAI;YACrB,OAAO;gBACH,MAAM,KAAK,IAAI;gBACf,SAAS,KAAK,OAAO;gBACrB,iBAAiB,KAAK,SAAS,EAAE,IAAI,CAAC,KAAY,CAAC;wBAC/C,YAAY,OAAO,UAAU;wBAC7B,UAAU,GAAG,IAAI;wBACjB,MAAM,GAAG,IAAI;wBACb,OAAO;wBACP,QAAQ,GAAG,MAAM;oBACrB,CAAC;YACL;QACJ,GACC,OAAO,IAAI,qCAAqC;QAErD,QAAQ,GAAG,CAAC,CAAC,gCAAgC,EAAE,SAAS,MAAM,CAAC,uBAAuB,EAAE,WAAW;QACnG,OAAO;IAEX,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,mDAAmD;QACjE,OAAO,EAAE;IACb;AACJ;AAMO,eAAe,YAClB,SAAiB,EACjB,IAAqC,EACrC,OAAe,EACf,QAIC;IAED,IAAI;QACA,MAAM,YAAY,IAAA,8IAAE;QAEpB,MAAM,cAAc;YAChB;YACA;YACA,WAAW,0KAAU,CAAC,eAAe;YACrC,GAAG,QAAQ;QACf;QAEA,+BAA+B;QAC/B,MAAM,UACD,UAAU,CAAC,kJAAW,CAAC,QAAQ,EAC/B,GAAG,CAAC,WACJ,UAAU,CAAC,kJAAW,CAAC,QAAQ,EAC/B,GAAG,CAAC;QAET,0BAA0B;QAC1B,MAAM,UACD,UAAU,CAAC,kJAAW,CAAC,QAAQ,EAC/B,GAAG,CAAC,WACJ,GAAG,CACA;YACI,WAAW,0KAAU,CAAC,eAAe;YACrC,cAAc,0KAAU,CAAC,SAAS,CAAC;YACnC,oBAAoB,QAAQ,SAAS,CAAC,GAAG;QAC7C,GACA;YAAE,OAAO;QAAK;QAGtB,QAAQ,GAAG,CAAC,CAAC,oBAAoB,EAAE,KAAK,qBAAqB,EAAE,WAAW;IAE9E,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,uCAAuC;IACrD,+DAA+D;IACnE;AACJ;AAKO,eAAe,cAAc,SAAiB;IACjD,IAAI;QACA,MAAM,YAAY,IAAA,8IAAE;QACpB,MAAM,aAAa,UAAU,UAAU,CAAC,kJAAW,CAAC,QAAQ,EAAE,GAAG,CAAC;QAElE,MAAM,UAAU,MAAM,WAAW,GAAG;QAEpC,IAAI,CAAC,QAAQ,MAAM,EAAE;YACjB,MAAM,WAAW,GAAG,CAAC;gBACjB,WAAW,0KAAU,CAAC,eAAe;gBACrC,WAAW,0KAAU,CAAC,eAAe;gBACrC,cAAc;gBACd,QAAQ;YACZ;YAEA,QAAQ,GAAG,CAAC,CAAC,qCAAqC,EAAE,WAAW;QACnE;IACJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,2CAA2C;IAC7D;AACJ"}},
    {"offset": {"line": 353, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/User01/.gemini/antigravity/scratch/renovation-next/web_client/app/api/chat/history/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\r\nimport { getConversationContext } from '@/lib/db/messages';\r\n\r\nexport const runtime = 'nodejs';\r\nexport const dynamic = 'force-dynamic';\r\n\r\n/**\r\n * GET /api/chat/history?sessionId=xxx\r\n * Load conversation history for a session\r\n */\r\nexport async function GET(req: NextRequest) {\r\n    try {\r\n        const { searchParams } = new URL(req.url);\r\n        const sessionId = searchParams.get('sessionId');\r\n\r\n        if (!sessionId) {\r\n            return NextResponse.json(\r\n                { error: 'sessionId is required' },\r\n                { status: 400 }\r\n            );\r\n        }\r\n\r\n        console.log('[GET /api/chat/history] Loading history for session:', sessionId);\r\n\r\n        // Load last 50 messages from Firestore\r\n        const messages = await getConversationContext(sessionId, 50);\r\n\r\n        console.log('[GET /api/chat/history] Loaded', messages.length, 'messages');\r\n\r\n        return NextResponse.json({\r\n            messages,\r\n            sessionId,\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('[GET /api/chat/history] Error:', error);\r\n        return NextResponse.json(\r\n            { error: 'Failed to load history' },\r\n            { status: 500 }\r\n        );\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;;;;;AAEO,MAAM,UAAU;AAChB,MAAM,UAAU;AAMhB,eAAe,IAAI,GAAgB;IACtC,IAAI;QACA,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,IAAI,GAAG;QACxC,MAAM,YAAY,aAAa,GAAG,CAAC;QAEnC,IAAI,CAAC,WAAW;YACZ,OAAO,gJAAY,CAAC,IAAI,CACpB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAEtB;QAEA,QAAQ,GAAG,CAAC,wDAAwD;QAEpE,uCAAuC;QACvC,MAAM,WAAW,MAAM,IAAA,+JAAsB,EAAC,WAAW;QAEzD,QAAQ,GAAG,CAAC,kCAAkC,SAAS,MAAM,EAAE;QAE/D,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB;YACA;QACJ;IAEJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,kCAAkC;QAChD,OAAO,gJAAY,CAAC,IAAI,CACpB;YAAE,OAAO;QAAyB,GAClC;YAAE,QAAQ;QAAI;IAEtB;AACJ"}}]
}